#!/usr/bin/python3 
# -*- mode: python -*-

# RMET: Rt METrics or something, i dont even remember tbqh

# http://requesttracker.wikia.com/wiki/REST

import sys
import os
import time
#import subprocess
import re
import datetime
#import xml.etree.ElementTree as ET
import http.client
import ssl
import argparse
import urllib
import configparser

configfile=os.path.abspath(os.path.expanduser('~/.qrt_config'))
svnbin = r'C:\Program Files\TortoiseSVN\bin\svn.exe'

def debugprint(text):
    print("DEBUG: " + str(text))

def previous_monday(refdate=datetime.date.today()):
    """Find the Monday most immediately preceding the given date.
    When passed a Monday, returns it right back.
    (Who really wants Mondays anyway?)
    """
    return refdate - datetime.timedelta(days=refdate.weekday())
def next_sunday(refdate=datetime.date.today()):
    """Find the Sunday most immediately following the given date.
    When passed a Sunday, returns it right back.
    """
    return refdate + datetime.timedelta(days=6-refdate.weekday())

class Ticket:
    def __init__(self, name="", tid=None, rtserver=None):
        if not tid:
            raise Exception("Tried to create a ticket with no ticket id; this is useless.")
        self.tid=tid

        if not rtserver:
            raise Exception("Tried to create a ticket with no rtserver; this is useless.")
        self.rtserver=rtserver

        self.url = "{}/Ticket/Display.html?id={}".format(self.rtserver.baseurl, self.tid)
        self.name=name

    def markdownify(self, nobullet=False):
        if nobullet:
            # return just the raw link
            return "[{}]({})".format(self.name, self.url)
        else:
            # return a bulleted link
            return "- [{}]({})".format(self.name, self.url)

class RTServer:
    def __init__(self, host, ssl=False, cacert=False, username="", password=""):
        self.host=host
        self.ssl=ssl
        self.cacert=cacert
        self.username=username
        self.password=password
        self.ticketowner=username
        self.bodyauth = "user={}&pass={}".format(username, password)

        if ssl:
            self.baseurl = 'https://'
        else:
            self.baseurl = 'http://'
        self.baseurl += host

        #self.setup_connection() #TODO: this is really not ideal.

    def setup_connection(self):
        if self.ssl:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            context.verify_mode = ssl.CERT_REQUIRED
            context.load_verify_locations(self.cacert)
            self.conn = http.client.HTTPSConnection(self.host, context=context)
        else:
            self.conn = http.client.HTTPConnection(self.host)

    def get_ticket(self, tid):
        self.setup_connection()
        urlpath=urllib.parse.quote("/REST/1.0/ticket/{}/show".format(str(tid)).format("utf8"))
        qurlpath=urllib.parse.quote(urlpath.encode("utf8"))
        debugprint(qurlpath)
        #self.conn = self.setup_connection()
        self.conn.request("POST", qurlpath, body=self.bodyauth)
        response = self.conn.getresponse()
        return response.read().decode()
    
    def get_query_results(self, query):
        self.setup_connection()
        urlpath="/REST/1.0/search/ticket?query={}".format(query).format("utf8")
        #qurlpath=urllib.parse.quote(urlpath.encode("utf8"))
        #qurlpath=urlpath
        qurlpath = re.sub(" ", "%20", urlpath)
        debugprint(qurlpath)
        #self.conn = self.setup_connection()
        self.conn.request("POST", qurlpath, body=self.bodyauth)
        response = self.conn.getresponse()
        response_text_orig = response.read().decode()

        # chomp the first 2 lines of the array because they are "RT/4.0.2 200 OK" and then a blank line
        response_array = response_text_orig.splitlines()[2:]

        if response_array[0] == 'No matching results.':
            debugprint("RT has no matching results, returning false...")
            return False

        ticket_array=[]
        for ticketline in response_array:
            m = re.match("([0-9]*): (.*)", ticketline)
            tid, tname = int(m.group(1)), m.group(2)
            ticket = Ticket(tid=tid, name=tname, rtserver=self)
            ticket_array.append(ticket)
        
        return ticket_array

    def build_query_daterange(self, startdate, enddate):
        """Build (part of) a query for date ranges.
        RT doesn't understand "from 3/15/12 to 4/15/12" but it can understand
        "Created>=2 days ago and Created<=today".
        """
        sd = int((datetime.date.today() - startdate).days)
        ed = int((datetime.date.today() - enddate).days)
        #query = "Created>={} days ago and Created<={} days ago".format(sd, ed)
        #debugprint(query)
        #return query
        debugprint("sd is a {} with value: {}".format(type(sd), sd))
        debugprint("ed is a {} with value: {}".format(type(ed), ed))
        return sd, ed

    def generate_subreport(self, refdate=None, startdate=None, enddate=None):

        # this is horrible and wrong but it will work and meh

        if not refdate and not startdate and not enddate:
            refdate=datetime.date.today()

        if refdate:
            if startdate or enddate:
                raise Exception("Passed both a refdate and also a start or end date.")
            startdate = previous_monday(refdate)
            enddate = next_sunday(refdate)
        elif startdate and not enddate:
            raise Exception("Passed a startdate but not an enddate.")
        elif enddate and not startdate:
            raise Exception("Passed an enddate but not a startdate.")

        markdown = "# {}'s progress report: {} to {}\n\n".format(self.username,
                                                             startdate.strftime("%Y-%m-%d"),
                                                             enddate.strftime("%Y-%m-%d"))

        #boilerplate that goes on everything
        query_owner = "Owner='{}' AND ".format(self.ticketowner)

        # get resolved tickets
        resolved_query = query_owner
        resolved_query+= "Status='resolved' AND Resolved>='{} days ago' and Resolved<='{} days ago'".format(
            startdate,enddate)
        resolved_tickets = self.get_query_results(resolved_query)

        markdown += "Tickets I resolved this week:\n\n"
        debugprint("RESOLVED TICKETS:")
        if resolved_tickets:
            for t in resolved_tickets:
                debugprint("\t{}".format(t.url))
                markdown += "{}\n".format(t.markdownify())
        else:
            markdown += "- (None.)\n"
        markdown += "\n"
        
        # this will get tickets that are new or have been modified in the daterange, but 
        # not rejected/resolved ones
        modified_query = query_owner
        modified_query+= "Status!='rejected' AND Status!='resolved' AND Status!='deleted' AND "
        modified_query+= "LastUpdated>='{} days ago' and LastUpdated<='{} days ago'".format(startdate, enddate)
        modified_tickets = self.get_query_results(modified_query)

        markdown += "Other tickets I worked on this week: \n\n"
        debugprint("MODIFIED TICKETS:")
        if modified_tickets:
            for t in modified_tickets:
                debugprint("\t{}".format(t.url))
                markdown += "{}\n".format(t.markdownify())
        else:
            markdown += "- (None.)\n"
        markdown += "\n"

        return(markdown)

    def build_week_query(refdate = datetime.date.today()):
        sd,ed = self.build_query_daterange(previous_monday(refdate), next_sunday(refdate))

    def build_test_rmet(self):
        #sd,ed = self.build_query_daterange(previous_monday(), datetime.date.today())        
        simple_query = "Status='new' AND Queue='sysadmin' and Resolved>='2 days ago'"
        #debugprint(resolved_query)
        simple_tickets = self.get_query_results(simple_query)
        return(simple_tickets)

class SVNRepository:
    """A wrapper class that contains information about SVN repositories. 
    url: the url of the repository
    viewvc: the url of the webpage that describes the commit
    desc: a description that would grammatically fit in this blank: 
          "Commits I made to _____", e.g. "the main repository"
    user: 
    password: 
    exclude: optional; if provided, it will exclude these paths from get_my_commits()
    """
    def __init__(self, url, viewvc, desc, user, password, exclude=None):
        self.url=url
        self.viewvc=viewvc
        self.desc=desc
        self.user=user
        self.password=password
        self.exclude=exclude
    def get_my_commits(self):
        """Find all commits to a repository which were authored by the user
        Returns an array of ElementTree Element objects
        You can get the same data in bash like so:
        svn log -v -r {2012-01-01}:{2012-02-15}  | sed -n '/| mrled |/,/-----$/ p'
        """
        svncmd = [svnbin, "log", "--xml", "-v", "-r", 
                  "{open}{start}{close}:{open}{end}{close}".format(open="{", close="}", 
                                                                   start=startdate.strftime("%Y-%m-%d"),
                                                                   end=enddate.strftime("%Y-%m-%d")),
                  self.url()]
        logxml = subprocess.check_output(svncmd)
        logxmltree = ET.fromstring(logxml)
        mycommits = []
        for entry in logxmltree.findall("logentry"):
            a = next(entry.iter("author")).text
            if a == self.user:
                appendme = True
                # this grabs all the <paths> in the XML and excludes each excluded path
                if self.exclude:
                    for expath in self.exclude:
                        for p in entry.iter("path"):
                            if p.text.startswith(expath):
                                appendme = False
                                break
                if appendme:
                    mycommits.append(entry)
        return mycommits
    def logentries_to_urls(self):
        """Returns an array of URLs for all my commits between startdate and today."""
        logentries=self.get_my_commits()
        urllist=[]
        for entry in logentries:
            r = entry.get("revision")
            urllist.append ( self.viewvc() + "?view=revision&revision=" + r)
        return urllist
    def logentries_to_urls_markdown(self):
        """Returns an array of Markdown strings for all my commits between startdate and today.
        Example: [1234](http://svn.example.com/repo1?view=revision&revision=1234)"""
        logentries=self.get_my_commits()

        mdlist=[]
        for entry in logentries:
            r = entry.get("revision")
            mdstring = "[" + r + "](" + self.viewvc() + "?view=revision&revision=" + r + ")"
            mdlist.append(mdstring)
        return mdlist

def generate_rmet(self, startdate, enddate, svnrepos=None):

    title = "# {}'s progress report: {} to {}\n\n".format(username,
                                                          startdate.strftime("%Y-%m-%d"),
                                                          enddate.strftime("%Y-%m-%d"))
    overview = None
    tickets = RT.generate_subreport(startdate=startdate, enddate=endddate)
    commits = None

    svntext = ""
    for r in repositories:
        commitstring=""
        urls = r.logentries_to_urls_markdown()
        if len(urls) > 0:
            commitstring = "Commits I made to {}: ".format(r.desc)
            for i in range(0,len(urls)):
                commitstring += urls[i]
                if i < len(urls)-1:
                    commitstring += ", "
            svntext += "- {}\n".format(commitstring)
        
    if (svntext != ""):
        commits = "## SVN commits\n" + svntext + "\n"


# BLOCKINGTODO: 
# i have to figure out how to pass start/end/ref dates to the program
# i'm still not happy with the way i'm using argparser and the query argument

def main(*args):
    argparser = argparse.ArgumentParser()

    h="Query for the RT API. Can be an integer, which is interpreted as a request to display a "
    h+="ticket ID, or a string, which is interpreted as a query to pass to RT's search."
    h+="Also accepts the special value 'pastweek', which returns a report of the past week's "
    h+="activities."
    argparser.add_argument('query', action='store', help=h)
    args = argparser.parse_args()

    config = configparser.ConfigParser()
    config.read(configfile)

    username = config['general']['username']
    password = config['general']['password']

    rt_host = config['rtserver']['host']
    rt_ssl = True if config['rtserver']['cacert'] else False
    rt_cacert = os.path.abspath(os.path.expanduser(config['rtserver']['cacert']))

    repositories = []
    for s in config.sections():
        if s.startswith('svn.'):
            # excludes are just a string; we need them to be a list
            if config[s]['exclude']:
                excl = config[s]['exclude'].split(",")
            else:
                excl = None

            nrepo = SVNRepository(config[s]['url'],
                                  config[s]['viewvc'],
                                  config[s]['desc'],
                                  username, 
                                  password,
                                  excl)
            repositories.append(nrepo)
    
    RT = RTServer(rt_host, 
                  ssl=rt_ssl,
                  cacert=rt_cacert, 
                  username = username,
                  password = password)

    if args.query == "pastweek":
        

        results = generate_rmet()
    elif args.query == "testq":
        results = RT.build_test_rmet()
    else:
        try:
            # attempt to see the query as an int
            results = RT.get_ticket(int(args.query))
        except ValueError:
            # didn't work, use it as a string
            results = RT.get_query_results(args.query)
    
    print(results)

if __name__ == '__main__':
    sys.exit(main(*sys.argv))





def old_program():

    output = ""
    
    def mungeoutput(output):
        #match a header of id\tSubject\n and a footer of just an extra \n
        headerfooter = re.compile("(id\tSubject\n)|(\n$)") 
    
        #match the begining of the line OR of the whole block of text
        linebegin = re.compile("^|\n") 
    
        #match an eof
        eof = re.compile("$")
    
        #match a ticket line, consisting of a ticket number, a tab, and a title
        #like "1234	Fix some horrifying problem by yesterday"
        ticketline = re.compile("([0-9]*)\t(.*)")
    
        #required b/c it comes to us from subprocess.check_output which returns a bytes object
        output = str(output, "utf-8") 
    
        ##now process the regexps
    
        #nuke header and footer
        output = re.sub(headerfooter, r"", output)
    
        #change line beginings to have bullets in front of them
        output = re.sub(linebegin, r"\n- ", output)
    
        #add an extra line at the end for... some reason
        output = re.sub(eof, r"\n", output)
    
        #make the ticket line into a Markdown link
        output = re.sub(ticketline, r"[\2](https://bugs.neuric.internal/Ticket/Display.html?id=\1)", output)
    
        return output
    
    today=datetime.date.today()
    
    # By default, check the last 6 days, but use the first argument if present
    if (len(sys.argv) <= 1):
        numdays=6
    else:
        numdays=int(sys.argv[1])
    updated="Updated >= '" + str(numdays) + " days ago'"
    startdate=today - datetime.timedelta(numdays)
    
    # Find resolved tickets
    cmd=[rtbin, "ls", "-f", "Subject", "-o", "-Created", 
         "Queue = '5' AND Status = 'resolved' AND " + updated]
    resolvedtickets=mungeoutput(subprocess.check_output(cmd))
    
    # Find modified tickets
    cmd=[rtbin, "ls", "-f", "Subject", "-o", "-Created", 
         "Queue = '5' AND Status != 'resolved' AND Status != 'rejected' AND " + updated]
    modifiedtickets=mungeoutput(subprocess.check_output(cmd))
    
    # Find rejected tickets
    cmd=[rtbin, "ls", "-f", "Subject", "-o", "-Created",
         "Queue = '5' AND Status = 'rejected' AND " + updated]
    rejectedtickets=mungeoutput(subprocess.check_output(cmd))
    
    # Now print them all. I'm using Markdown, which means it's easy to just do `rmet.py|markdown.pl`
    # or if I want to add notes or something I can do it in markdown format at the bottom first
    output += "# Micah's progress report: " + startdate.strftime("%Y%m%d") + " to " + today.strftime("%Y%m%d") + "\n"
    output += "\nTickets I resolved this week:\n"
    output += resolvedtickets
    output += "\nOther tickets I worked on this week:\n"
    output += modifiedtickets
    output += "\nTickets I rejected this week:\n"
    output += rejectedtickets
    
    
    # Make sure each repo you want counted is in this dictionary with a meaningful name! 
    class SVNRepository:
        """A wrapper class that contains information about SVN repositories. 
        shortname: a short name for the repository, currently unused
        path: the server-side path for the repository
        desc: a description that would grammatically fit in this blank: 
              "Commits I made to _____", such as "the main repository"
        baseurl: the first part of the URL to the SVN server. This is probably 
                 static across the whole organization, and is optional. 
        """
        def __init__(self, shortname, path, desc, baseurl=None):
            self.shortname=shortname
            self.path=path
            self.desc=desc
            if baseurl==None:
                self.baseurl='https://svn.neuric.internal'
        def repo_url(self):
            return self.baseurl + self.path
        def viewvc_url(self):
            return self.baseurl + "/viewvc" + self.path
        def get_my_commits(self):
            """Find all commits to a repository which were authored by svnauthor (defined above)
            Returns an array of ElementTree Element objects
            You can do this in bash like so: 
            svn log -v -r {2012-01-01}:{2012-02-15}  | sed -n '/| mrled |/,/-----$/ p'
            """
            svncmd = [svnbin, "log", "--xml", "-v", "-r", 
                      "{open}{start}{close}:{open}{end}{close}".format(open="{", close="}", 
                                                                       start=startdate.strftime("%Y-%m-%d"),
                                                                       end=enddate.strftime("%Y-%m-%d")),
                      self.repo_url()]
            #sys.stderr.write("SVN log command: " + " ".join(svncmd) + "\n")
            logxml = subprocess.check_output(svncmd)
            logxmltree = ET.fromstring(logxml)
            mycommits = []
            for entry in logxmltree.findall("logentry"):
                a = next(entry.iter("author")).text
                if a == svnauthor:
                    appendme = True
                    # Now skip the useless commits regarding the very reports we are generating here (lulz)
                    for p in entry.iter("path"):
                        if p.text.startswith("/Presentations/Weekly Presentations"):
                            appendme = False
                            break
                    if appendme:
                        mycommits.append(entry)
            # stupid hack because "Documentation/Presentations/Weekly Presentations" 
            # is where we commit these metrics reports every week.
            # don't include those commits in the list...
            return mycommits
        def logentries_to_urls(self):
            """Returns an array of URLs for all my commits between startdate and today."""
            logentries=self.get_my_commits()
            urllist=[]
            for entry in logentries:
                r = entry.get("revision")
                urllist.append ( self.viewvc_url() + "?view=revision&revision=" + r)
            return urllist
        def logentries_to_urls_markdown(self):
            """Returns an array of Markdown strings for all my commits between startdate and today.
            Example: [1234](http://svn.example.com/repo1?view=revision&revision=1234)"""
            logentries=self.get_my_commits()
    
            mdlist=[]
            for entry in logentries:
                r = entry.get("revision")
                mdstring = "[" + r + "](" + self.viewvc_url() + "?view=revision&revision=" + r + ")"
                mdlist.append(mdstring)
            return mdlist
    
    repos = {
        SVNRepository('ikiadmin', "/sysadmin/ikiadmin/trunk", desc="the sysadmin documentation wiki"),
        SVNRepository('nasrc', "/sysadmin/nasrc", desc="the sysadmin script repository"),
        SVNRepository('neuric', "/source/neuric", desc="the Neuric source code repository"),
        SVNRepository('documentation', "/source/documentation", desc="the Neuric documentation repository"),
    }
    
    
    svntext = ""
    for r in repos:
        commitstring=""
        urls = r.logentries_to_urls_markdown()
        if len(urls) > 0:
            commitstring = "Commits I made to " + r.desc + ": "
            for i in range(0,len(urls)):
                commitstring += urls[i]
                if i < len(urls)-1:
                    commitstring += ", "
            svntext += "- " + commitstring + "\n"
    
    if (svntext != ""):
        output += "## SVN commits\n"
        output += svntext + "\n"
    
    
    # Markdownify
    
    htmltitle  = "Micah's progress report, " + startdate.strftime("%Y-%m-%d") + " - " + today.strftime("%Y-%m-%d")
    htmloutput = "<html><head>" + htmltitle + "</head><body>\n" + markdown.markdown(output) + "</body></html>"
    
    print(htmloutput)
    


    
