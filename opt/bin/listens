#!/usr/bin/env python3
# -*- mode: python -*-

import os, sys, subprocess, re, copy

DEBUG_MODE = False
#DEBUG_MODE = True
def DEBUG(x):
    if DEBUG_MODE: 
        print("DEBUG: " + x)

class Listener: 
    def __init__(self):
        self.proto = ""
        self.addr = ""
        self.port = ""
        self.servicename = ""
        self.servicecomment = ""
        self.ltype = ""
        self.proc_info = {}
        self.pids = []
        self.pid_str = ""
        self.exe_str = ""

    def init_instvars(self, proto, addr, port, servicename, servicecomment, ltype):
        self.proto = proto
        self.addr = addr
        self.port = port
        self.servicename = servicename
        self.servicecomment = servicecomment
        self.ltype = ltype
        self.proc_info = {}
        self.pids = []
        self.pid_str = ""
        self.exe_str = ""
        self.get_priv_info()

    @classmethod
    def header_listener(self):
        """
Return not an actual listener, but one that can be used as a header line.
There are probably better ways to do this, idk. 
"""
        new_listener=Listener()
        new_listener.init_instvars("Proto", "Address", "Port", "Service name", "Service comment", "header")
        new_listener.portproto = "Port.Prot"
        new_listener.pid_str = "PIDs (may require root)"
        new_listener.exe_str = "Executable name"
        new_listener.proc_info['PID'] = 'Exe Name'
        #new_listener.pids = "PIDs (may require root)"
        return new_listener
    @classmethod
    def listener_from_listenline(self,listen_line):
        "Expect a single line from the output of 'netstat -an'"
        new_listener=Listener()
        new_listener.input_line=(listen_line) #not sure if we'll need this later but just in case
        line_array = re.split(r"\s+", listen_line)
        new_listener.proto = line_array[0]

        proto_re = re.compile(r'([a-zA-Z]+).*')
        new_listener.versionless_proto = proto_re.match(line_array[0]).group(1)

        try:
            ap = new_listener.separate_addrport(line_array[3])
        except Exception as e:
            print("""
Error when trying to split address from port.
The problematic line: '{}'
""".format(listen_line, line_array[3]))
            raise
            
        new_listener.addr=ap[0]
        new_listener.port=ap[1]
        new_listener.portproto=str(new_listener.port + '.' + new_listener.versionless_proto)
        new_listener.ltype="listener"
        new_listener.lookup_name() #populates self.service and self.desc
        new_listener.get_priv_info()
        return new_listener

    def get_priv_info(self):
        """If we're root, get info that only root can see."""
        if not os.getuid() == 0: return
        if self.ltype == "header": return
        self.get_pids()

    def get_pids(self):
        "Gets the pid(s) for a port number. Requires root privs to do this for processes that aren't yours." 
        if self.ltype == "header": return
        if self.proto == "tcp6": 
            DEBUG("lsof can't deal with ipv6 addresses, ugh. Can't get_pids for port {}".format(self.port))
            return
        lsof_bin=find_in_system_path("lsof")
        lsof_cmd=[lsof_bin, "+M", "-t", "-i", '@' + self.addr + ':' + self.port]
        lsof_output=""
        try:
            lsof_output=subprocess.check_output(lsof_cmd)#this should return a simple process name
        except subprocess.CalledProcessError as cpe:
            pass
        finally:
            # re.split() will result in an empty string because there's a trailing newline... 
            # get rid of that with the remove() call. 
            lsof_pids=re.split(r'\n', lsof_output.decode("utf-8"))
            lsof_pids.remove("")
            #self.pid_str = ""
            for pid in lsof_pids:
                #self.pid_str += str(pid) + " "
                self.proc_info[pid] = pid # for now, set the exe name to just be the PID; we'll fix this later

    def lookup_name(self):
        if self.ltype == "header": return
        services_file = open('/etc/services', 'r')
        services_re = re.compile(r"(\S+)\s+" + self.portproto + "\s+(.*)", re.M)
        for serviceline in services_file: 
            match = services_re.match(serviceline)
            if match:
                self.servicename = match.group(1)
                self.servicecomment = match.group(2)
                break
        else:
            self.servicename = "?"
            self.servicecomment = "??"
        services_file.close()

    def padded_port(self):
        # useful for sorting
        p_port = '{:0>5}'.format(self.port)
        return p_port

    def separate_addrport(self, addrport):
        """addrport is the address/port column of netstat -an output
        It might look like one of these: 
        - 0.0.0.0.17500
        - ::1:631 -- ipv6 local interface, port 631
        - :::22 -- all ipv5 interfaces, port 22
        - ::.22 -- maybe? same, but in os x notation
        - 2.2.2.2.2 -- addr 2.2.2.2, port 2, mac os x notation
        - *.84 -- I think Linux doesn't do '*', but OS X does
        - don't forget about giant long ass ipv6 addresses, which also might be here. 
        The address/port separator is either '.' (on at least OS X) or ':' (on at least Linux)
        The address/port string should look something like: *.#, octet.#, ::1.#, ipv6.#, :::2, 
        Return a list with the address in slot 0 and port in slot 1
        """
        ap_match = re.match(r'(.*)[:\.]([0-9]{0,5})', addrport)
        a=ap_match.group(1)
        p=ap_match.group(2)
        return [a,p]

    def printable(self):
        # proto is 4-5 chars - tcp4, tcp64
        # addr could be just one, or 3, or 15 - *, ::1, 233.233.233.233
        #     at most 39: 2001:0db8:85a3:0000:0000:8a2e:0370:7334
        # port is 1-5
        # service (name) seems to be 15 wide, at least on OS X, whose /etc/services claims to be from FreeBSD
        # service comment maxes out at 89 on the same system, but all others are under 55 chars wide

        #output =  'protocol: {:<6}  port: {:<6}  service: {:<15}  desc: {:<30}  address: {:<40}'.format(
        #    self.proto, self.port, self.servicename, self.servicecomment, self.addr)

        #output = '{:<9}  {:<15}  {:<30}  {:<39}'.format(
        #    self.portproto, self.servicename, self.servicecomment, self.addr)


        # I'm considering using a '.' as a padding character, rather than space...
        # on the address line at least. try it both ways: {:.<39} or just {:<39}
        output = '{:<5}  {:>5}  {:<39}  {:<15}  {:<30}'.format(
            self.proto, self.port, self.addr, self.servicename, self.servicecomment)

        return output

class ListenersArray:
    """A wrapper for an array of listeners. Provides header, ordering, printing"""
    def __init__(self):
        self._array=[]
    def sort_by(self, criterion):
        if (criterion == "port"):
            tmparray = sorted(self._array, key=lambda listener: listener.padded_port())
            self._array=tmparray
    def sort(self):
        self.sort_by("port")
    def append_line(self, listen_line):
        l = Listener.listener_from_listenline(listen_line)
        if not l:
            raise Exception("Failed to create new Listener object from listener line")
        else:
            self._array.append(l)
    def append_listener(self, listener):
        if type(listener) is not Listener:
            raise Exception("Object passed to ListenersArray.append_listener was not a Listener object")
        else: 
            self._array.append(listener)
    def print_listeners(self):
        """Print out the list of listening services
        We add the header item now to a separate array so we don't fuck up sorting.
        Some things like port or protocol are a fixed length, but longer things like address
        and service name are variable
        """
        #array_with_header = [Listener.header_listener(), ]
        #for item in self._array:
        #    array_with_header.append(item)
        header_l = Listener.header_listener()
        self._array.insert(0, header_l)
        len_addr = len_svc = len_comment = len_exe = 0
        for l in self._array:
            # doing it this way includes the lenght of the header fields too
            if len(l.addr) > len_addr:
                len_addr = len(l.addr)
            if len(l.servicename) > len_svc:
                len_svc = len(l.servicename)
            if len(l.servicecomment) > len_comment:
                len_comment = len(l.servicecomment)
            if len(l.exe_str) > len_exe:
                len_exe = len(l.exe_str)

        len_proto = 5
        len_port = 5
        len_spacer = 2
        len_pid = 5

        idx_proto = 0
        idx_port = idx_proto + len_proto + len_spacer
        idx_addr = idx_port + len_port + len_spacer
        idx_svc = idx_addr + len_addr + len_spacer

        output = ""
        for l in self._array:
            output += '{pr:<{prlen}}  {p:>{plen}}  {a:<{alen}}  '.format(
                pr=l.proto, p=l.port, a=l.addr, prlen=len_proto, plen=len_port, alen=len_addr)
            output += '{svc:<{svclen}}  {comm:<{commlen}}'.format(
                svc=l.servicename, comm=l.servicecomment, 
                alen=len_addr, svclen=len_svc, commlen=len_comment)
            if len(l.proc_info.keys()) > 0 and not l.ltype == "header":
                #output+='{pr:<5}  {p:>5}  {a:<{alen}}  '.format(
                #    pr=l.proto, p=l.port, a=l.addr, prlen=len_proto, plen=len_port, alen=len_addr)
                for process in l.proc_info.keys():
                    output += '\n{empty_char:{fill_len}}'.format(empty_char=' ', fill_len=idx_svc)
                    #output+= 'PID: {pid:<{pidlen}}  Exe: {exe:<{exelen}}'.format(
                    output+= '{pid:<{pidlen}} / {exe:<{exelen}}'.format(
                        pid=process, pidlen=len_pid, exe=l.proc_info[process], exelen=len_exe)
            output += "\n"

        sys.stdout.write(output) #print() will add an extra newline
        self._array.remove(header_l)
            

def find_in_system_path(exename):
    path_e = os.environ['PATH']
    path_e_array = re.split(':', path_e)
    for p in path_e_array:
        trypath = p + '/' + exename
        if os.path.exists(trypath): return trypath
    else:
        raise Exception("Failed to find command '{}' in system $PATH variable, exiting...".format(exename))


def main(*args):
    netstat_bin = find_in_system_path('netstat')
    netstat_cmd=[netstat_bin, "-an"]
    netstat_output = str(subprocess.check_output(netstat_cmd), "utf-8")
    netstat_output_array = re.split(r"\n", netstat_output, flags=re.M) # it is *much* easier to work with like this
    
    listen_re = re.compile(r".*((tcp)|(udp)).*LISTEN.*", re.M)
    DEBUG("listen_re is " + listen_re.pattern)
    la = ListenersArray()
    for line in netstat_output_array:
        if listen_re.search(line):
            DEBUG('Appending line: ' + line) 
            la.append_line(line)
            
    la.sort() #sort by port number
    la.print_listeners()

if __name__ == '__main__':
    sys.exit(main(*sys.argv))


