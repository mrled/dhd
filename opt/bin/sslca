#!/bin/bash

cmdname=$(basename $0)

usage() {
cat <<EOF
$cmdname: Perform basic tasks for a mini-PKI

This script can generate private keys and CRLs and sign them with a CA certificate. 

It has several subcommands: 

$cmdname help              Show this message
$cmdname genkey            Generate a private key & CRL for a server
$cmdname sign              Sign a CRL with an existing CA key
$cmdname gensign           Do both in one step

It expects you to pass it one or more base names, such as "sub.domain.tld", as arguments. For example: 

$cmdname genkey myserver.tld

It will create files with names based on this, such as myserver.tld.key and myserver.tld.cert. 

Note: the genkey (and also the gensign) subcommand will look for an openssl configuration file named myserver.tld.openssl.cnf. If it does not find one, it will copy openssl.cnf.client-DEFAULT to myserver.tld.openssl.cnf and open your editor on that file. 

EOF
}

generate_private_key() {
    for basename in $*; do
        openssl genrsa -out $basename.key 4096
        if [ ! -e $basename.openssl.cnf ]; then
            cp openssl.cnf.client-DEFAULT $basename.openssl.cnf
            $EDITOR $basename.openssl.cnf
        fi
        openssl req -new -nodes -config $basename.openssl.cnf -key $basename.key -out $basename.csr
    done
}

sign_certs() {
    for basename in $*; do
        openssl ca -batch -config openssl.cnf.ca -in $basename.csr -out $basename.cert -days 7300
    done
}


case $1 in 
    help)
        shift
        usage
        exit
        ;;
    sign)
        shift
        echo "Signing certificates..."
        sign_certs $*
        exit
        ;;
    genkey)
        shift
        echo "Generating private keys..."
        generate_private_key $*
        exit
        ;;
    gensign)
        shift
        echo "Generating private keys & signing certificates..."
        generate_private_key $*
        sign_certs $*
        exit
        ;;
esac
