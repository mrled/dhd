#!/bin/bash

username=`whoami`
otherhost="-"
port=1034
wait=0

function usage {
cat <<EOF
Usage: $0 [-u USERNAME] [-p PORT NUMBER] [-w SECONDS] <-h HOSTNAME>

Note that the -h argument is required, and that -w and -p arguments must be integers

Example: $0 -u me -p 1025 -h laptop.example.com

This utility is intended for such scenarios as when you have made some changes to the networking configuration on a remote server, and want to restart the networking stack, but want to have a way back in in case your changes prevent you from connecting via ssh. Obviously it will require that the remote computer still at least have a working outgoing network connection, but in case of something like firewall or DNS misconfiguration, this script can prevent a midnight trip down to the datacenter. 

Let's say you have a laptop: 
- hostname: laptop.example.com
- username: me

And you also have a server: 
- hostname: server.example.com
- username: sysadmin

If you want to restart networking on the server, first run a command like this on the server:  
    sysadmin@server> $0 -w 30 -u me -p 1025 -h laptop.example.com

Then, run your script to restart networking. If you find that your changes prevent you from getting back in to your server via ssh, run a command like this on your laptop: 
    me@laptop> ssh sysadmin@localhost -p 1025

(NOTE: be sure you're connecting to your laptop on the port you specify, but using the username you have on the server!)

And then provide the password for the sysadmin@server.example.com user. Note that you will see the ssh key from SERVER.EXAMPLE.COM, but since you connected to just a different port on the hostname LAPTOP.EXAMPLE.COM, ssh will add server.example.com's ssh key to ~/.ssh/known_hosts as belonging to laptop.example.com, which probably isn't what you want. I've created an alias in my .bashrc called "sshtel" which tells ssh not to check host the host key, but also not to save it; it looks like this: 
    alias sshtel="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

Also, note that you can connect even from another host (assuming your laptop's firewall allows it). Just tell it to connect to your laptop on the port you specified, like this: 
    anotheruser@anotherhost> ssh sysadmin@laptop.example.com -p 1025

Command line arguments: 

-u is the username on your laptop
-h is the hostname of your laptop
-p is the port num to use
-w is the wait time in seconds; don't use this unless you have keyless login 
   set up from sysadmin@server to me@laptop, because it waits this many
   seconds before even attempting to start the tunnel

TODO: 

- accept a password as well so that you don't need keyless login

EOF
}

while getopts "u:h:p:w:" opt; do
    case $opt in 
        u) 
            username=$OPTARG
            ;;
        h)
            otherhost=$OPTARG
            ;;
        p) 
            if [[ $OPTARG != [0-9]* ]]; then
                echo "The -p option must be an integer, to use as a port number. (Defaults to $port.)"
                usage
                exit
            fi
            port=$OPTARG
            ;;
        w)
            if [[ $OPTARG != [0-9]* ]]; then
                echo "The -w option must be an integer, in seconds, to wait. (Defaults to 0.)"
                usage
                exit
            fi
            wait=$OPTARG
            ;;
        esac
    done

if [ "$otherhost" = "-" ]; then 
    echo "You must at least provide a host with the -h option."
    exit
fi

sleep $wait && nohup ssh -f -N -R $port:localhost:22 $username@$otherhost
