#!/bin/bash

thiscmd=`basename $0`
username=`whoami`
otherhost="-"
port=1034
wait=0

USAGE="usage: $thiscmd [-h] [-p portnum] [-w waitsecs] [user@]host"

function verboseusage {
    echo $USAGE
    cat <<EOF

SBD - the Ssh Back Door

EXAMPLE:

You have a laptop (laptop.example.com, username "me") and a remote server (server.example.com, username "sysadmin"). You want to make a change to the server's firewall, but you want to make sure you have a way back in if your configuration is bad. 

    sysadmin@server.example.com$ $thiscmd -w 12 -p 1034 me@laptop.example.com

This invocation will wait 12 seconds, and invoke ssh to me@laptop.example.com, tunnelling laptop.example.com:1025 to server.example.com:22.

As a result, once you've waited 12 seconds, you can run a command like this:

    me@laptop.example.com$ ssh -p 1034 sysadmin@localhost

To actually get a shell as sysadmin@server.example.com. (Note: make sure you're on your laptop, connecting to localhost, but as the username you have on your server.)

You can also connect even from another host (assuming your laptop's firewall allows it). Just tell it to connect to your laptop on the port you specified, like this: 

    anotheruser@anotherhost$ ssh -p 1034 sysadmin@laptop.example.com

ARGUMENTS: 

-h this help message
-p is the port num to use; default is 1034
-w is the wait time in seconds; default is 0
   don't use this unless you have keyless login set up from sysadmin@server 
   to me@laptop, because it waits this many seconds before even attempting 
   to start the tunnel, which means it waits this many seconds before
   asking you for your password

CAVEATS:

Note that you will see the ssh key from SERVER.EXAMPLE.COM, but since you connected to just a different port on the hostname LAPTOP.EXAMPLE.COM, ssh will add server.example.com's ssh key to ~/.ssh/known_hosts as belonging to laptop.example.com, which probably isn't what you want. I've created an alias in my .bashrc called "sshtel" which tells ssh not to check host the host key, but also not to save it; it looks like this: 

    alias sshtel="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

TODO: 

- accept a password as well so that you don't need keyless login
- automate the command for connecting back in from the laptop

EOF
}

# parse arguments with options preceded by a dash
while [[ ${1:0:1} = '-' ]] ; do
    N=1
    L=${#1}
    while [[ $N -lt $L ]] ; do
        case ${1:$N:1} in
            'h') verboseusage; exit 1;;
            'p') 
                if [[ $N -ne $(($L-1)) || ! -n ${2} ]] ; then
                    echo $USAGE
                    exit 1
                fi
                portnum=${2}
                shift ;;
            'w') 
                if [[ $N -ne $(($L-1)) || ! -n ${2} ]] ; then
                    echo $USAGE
                    exit 1
                fi
                wait=${2}
                shift ;;
            *) echo $USAGE
                exit 1 ;;
        esac
        N=$(($N+1))
    done
    shift
done

# make sure that there remains an additional argument: the user@hostname string
if [[ ! -n ${1} ]] ; then
    echo $USAGE
    exit 1
fi

otherhost=`echo $1 | awk 'BEGIN { FS = "@" } ; { print $2 }'`
if [ x$otherhost = "x" ]; then 
    otherhost=$1
else
    username=`echo $1 | awk 'BEGIN { FS = "@" } ; { print $1 }'`
fi

echo "Waiting $wait secs before connecting to $username@$otherhost..."
echo "Make sure that port $port on $otherhost is unused and not blocked by a firewall!"
(sleep $wait && nohup ssh -f -N -R $port:localhost:22 $username@$otherhost) &