#!/bin/bash

smbclient="env smbclient"

function smbhelp {
cat <<EOF
This wrapper was designed because the syntax for smbclient is a huge piece of shit. Seriously. Who the hell decided to emulate the user friendliness of ftp for the love.

USAGE: 
You might use this script like so:
smbput file1 (file2...fileN) //server/share/path/to/somewhere
To see the available shares on a server, use:
smbclient -L //server

Samba includes its own smbget command, for which I will refer
the user to its own manual.
If you want to see smbclient's own silly syntax, here's some:
smbclient [-U username|-N] //server/share [password] <<DONEWITHTHAT
cd /path/to/somewhere
prompt
mput some files
exit
DONEWITHTHAT
Note that you should never put a trailing / after the share or
smbclient will be a giant fucking gay baby about it

FUTURE: 
- Grab all the things I need, and pass everything else on to smbclient.
  (That would certainly be the correct thing to do.) 
- Pass the -N argument to smbclient unless the user specifically 
  provides a username on the command line.
- Possibly support URL syntax instead of this shit
  (e.g. smb://[username[:password]@]server/share/path/)
- I have no idea how good my error handling is at present. (Probably
  awesome because I've put zero thought into it.) Investigate. 

EOF
}


# we are expecting a serverstring like //micah@micah-pc/Users/Micah/Downloads
# or i could do URLs: 
# smb://me:password@micah-pc/Users/Micah/Downloads

# OK I think I'm going to revise that. 
# it's too hard to parse real passwords in that syntax anyway; they might contain all 
# kinds of special characters and parsing those will be a pain in the ass
# so we're just going to accept user@server/share/path/

function parse_serverstring {
    server=
    share=
    path=
    user=

## all this code needs to be reconsidered in light of the new syntax: 
    # strip out smb:// from the URL, if present
    serverstring=`echo $1 | sed 's/smb:\/\///'`
    if [ `echo $serverstring | cut -c1,2` == '//' ]; then # assume //server[/share[/path]] ? 
        server=`echo $serverstring | awk 'BEGIN {FS="/"}; {print $3}'`
        share=`echo  $serverstring | awk 'BEGIN {FS="/"}; {print $4}'`
        path=`echo   $serverstring | sed s/"\/\/$server\/$share\/"//`
    else # assume [user[:pass]@]server[/share[/path]]
        server=`echo $serverstring | awk 'BEGIN {FS="/"}; {print $1}'`
        share=`echo  $serverstring | awk 'BEGIN {FS="/"}; {print $2}'`
        path=`echo   $serverstring | sed s/"\/\/$server\/$share\/"//`
    fi
    smburl=( $server $share $path $user )
    return $smburl
}

function ls {
    c=
    myurl=`parse_serverstring "$2"`
    if (${myurl[3]}; then
        # we are NOT anonymous
        if (${myurl[1]} == "/"); then
            # we are simply listing shares
            $smbclient -U ${myurl[3]} -L ${myurl[0]}
        else
            # we are listing the contents of an actual path
            $smbclient -U //${myurl[0]}/${myurl[1]} ${password} <<EOF
cd ${myurl[2]}
prompt
ls
exit
EOF

- are we anon? 
- are we enumerating shares, or looking at the files in them? 

    $smbclient -U $user 
}

function put {
    serverstring=${!#} # ${!#} is the final arg 
    # we are expecting a serverstring like //micah-pc/Users/Micah/Downloads
    server=`echo $serverstring | awk 'BEGIN {FS="/"}; {print $3}'`
    share=`echo  $serverstring | awk 'BEGIN {FS="/"}; {print $4}'`
    destination=`echo $serverstring | sed s/"\/\/$server\/$share\/"//`

    smbclient -U $user $server/$share $password <<EOF
prompt
cd $destination
mput $files
exit
EOF
}
